import React__default, { Children, useRef, useState, useEffect } from 'react';
import sx from '../../sx.js';
import { invariant } from '../../utils/invariant.js';
import { warning } from '../../utils/warning.js';
import styled from 'styled-components';
import { get } from '../../constants.js';
import { getAnchoredPosition } from '@primer/behaviors';
import { isSupported, apply } from '@oddbird/popover-polyfill/fn';
import { useId } from '../../hooks/useId.js';
import { useProvidedRefOrCreate } from '../../hooks/useProvidedRefOrCreate.js';
import Box from '../../Box/Box.js';

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Reusable styles to use for :popover-open (Chrome, Edge) and \:popover-open (Safari, Firefox) classes
const popoverStyles = `
    padding: 0.5em 0.75em;
    width: max-content;
    height: fit-content;
    margin: auto;
    clip: auto;
    white-space: normal;
    /* for scrollbar */
    overflow: visible;
`;
const animationStyles = `
  animation-name: tooltip-appear;
  animation-duration: 0.1s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-in;
  animation-delay: 0s;
`;
const StyledTooltip = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltip",
  componentId: "sc-5xkifj-0"
})(["width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;position:fixed;font:normal normal 11px/1.5 ", ";-webkit-font-smoothing:subpixel-antialiased;color:", ";text-align:center;word-wrap:break-word;background:", ";border-radius:", ";border:0;opacity:0;max-width:250px;inset:auto;@media (forced-colors:active){outline:1px solid transparent;}z-index:2147483647;display:block;&:popover-open{", "}&.\\:popover-open{", "}&::after{position:absolute;display:block;right:0;left:0;height:8px;content:'';}&[data-direction='n']::after,&[data-direction='ne']::after,&[data-direction='nw']::after{top:100%;}&[data-direction='s']::after,&[data-direction='se']::after,&[data-direction='sw']::after{bottom:100%;}&[data-direction='w']::after{position:absolute;display:block;height:100%;width:8px;content:'';bottom:0;left:100%;}&[data-direction='e']::after{position:absolute;display:block;height:100%;width:8px;content:'';bottom:0;right:100%;margin-left:-8px;}@keyframes tooltip-appear{from{opacity:0;}to{opacity:1;}}&:popover-open,&:popover-open::before{", "}&.\\:popover-open,&.\\:popover-open::before{", "}", ";"], get('fonts.normal'), get('colors.fg.onEmphasis'), get('colors.neutral.emphasisPlus'), get('radii.2'), popoverStyles, popoverStyles, animationStyles, animationStyles, sx);
// map tooltip direction to anchoredPosition props
const directionToPosition = {
  nw: {
    side: 'outside-top',
    align: 'start'
  },
  n: {
    side: 'outside-top',
    align: 'center'
  },
  ne: {
    side: 'outside-top',
    align: 'end'
  },
  e: {
    side: 'outside-right',
    align: 'center'
  },
  se: {
    side: 'outside-bottom',
    align: 'end'
  },
  s: {
    side: 'outside-bottom',
    align: 'center'
  },
  sw: {
    side: 'outside-bottom',
    align: 'start'
  },
  w: {
    side: 'outside-left',
    align: 'center'
  }
};

// map anchoredPosition props to tooltip direction
const positionToDirection = {
  'outside-top-start': 'nw',
  'outside-top-center': 'n',
  'outside-top-end': 'ne',
  'outside-right-center': 'e',
  'outside-bottom-end': 'se',
  'outside-bottom-center': 's',
  'outside-bottom-start': 'sw',
  'outside-left-center': 'w'
};

// The list is from GitHub's custom-axe-rules https://github.com/github/github/blob/master/app/assets/modules/github/axe-custom-rules.ts#L3
const interactiveElements = ['a[href]', 'button:not(:disabled)', 'summary', 'select', 'input:not([type=hidden])', 'textarea'];
const isInteractive = element => {
  return interactiveElements.some(selector => element.matches(selector)) || element.hasAttribute('role') && element.getAttribute('role') === 'button';
};
const TooltipContext = /*#__PURE__*/React__default.createContext({});
const Tooltip = /*#__PURE__*/React__default.forwardRef(({
  direction = 's',
  text,
  type = 'description',
  children,
  ...rest
}, forwardedRef) => {
  const tooltipId = useId();
  const child = Children.only(children);
  const triggerRef = useProvidedRefOrCreate(forwardedRef);
  const tooltipElRef = useRef(null);
  const [calculatedDirection, setCalculatedDirection] = useState(direction);
  const openTooltip = () => {
    if (tooltipElRef.current && triggerRef.current && !tooltipElRef.current.matches(':popover-open')) {
      tooltipElRef.current.showPopover();
    }
  };
  const closeTooltip = () => {
    if (tooltipElRef.current && triggerRef.current && tooltipElRef.current.matches(':popover-open')) {
      tooltipElRef.current.hidePopover();
    }
  };
  useEffect(() => {
    if (!tooltipElRef.current || !triggerRef.current) return;
    /*
     * ACCESSIBILITY CHECKS
     */
    // Has trigger element or any of its children interactive elements?
    const isTriggerInteractive = isInteractive(triggerRef.current);
    const triggerChildren = triggerRef.current.childNodes;
    const hasInteractiveChild = Array.from(triggerChildren).some(child => {
      return child instanceof HTMLElement && isInteractive(child);
    });
    !(isTriggerInteractive || hasInteractiveChild) ? process.env.NODE_ENV !== "production" ? invariant(false, 'The `Tooltip` component expects a single React element that contains interactive content. Consider using a `<button>` or equivalent interactive element instead.') : invariant(false) : void 0;
    // If the tooltip is used for labelling the interactive element, the trigger element or any of its children should not have aria-label
    if (type === 'label') {
      const hasAriaLabel = triggerRef.current.hasAttribute('aria-label');
      const hasAriaLabelInChildren = Array.from(triggerRef.current.childNodes).some(child => child instanceof HTMLElement && child.hasAttribute('aria-label'));
      process.env.NODE_ENV !== "production" ? warning(hasAriaLabel || hasAriaLabelInChildren, 'The label type `Tooltip` is going to be used here to label the trigger element. Please remove the aria-label from the trigger element.') : void 0;
    }

    // SSR safe polyfill apply
    if (typeof window !== 'undefined') {
      if (!isSupported()) {
        apply();
      }
    }

    /*
     * TOOLTIP POSITIONING
     */
    const tooltip = tooltipElRef.current;
    const trigger = triggerRef.current;
    tooltip.setAttribute('popover', 'auto');
    const settings = {
      side: directionToPosition[direction].side,
      align: directionToPosition[direction].align
    };
    const positionSet = () => {
      const {
        top,
        left,
        anchorAlign,
        anchorSide
      } = getAnchoredPosition(tooltip, trigger, settings);
      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;
      // This is required to make sure the popover is positioned correctly i.e. when there is not enough space on the specified direction, we set a new direction to position the ::after
      const calculatedDirection = positionToDirection[`${anchorSide}-${anchorAlign}`];
      setCalculatedDirection(calculatedDirection);
    };
    tooltip.addEventListener('toggle', positionSet);
    return () => {
      tooltip.removeEventListener('toggle', positionSet);
    };
  }, [tooltipElRef, triggerRef, direction, type]);
  return /*#__PURE__*/React__default.createElement(TooltipContext.Provider, {
    value: {
      tooltipId
    }
  }, /*#__PURE__*/React__default.createElement(Box, {
    sx: {
      display: 'inline-block'
    },
    onMouseLeave: () => closeTooltip()
  }, /*#__PURE__*/React__default.isValidElement(child) && /*#__PURE__*/React__default.cloneElement(child, {
    ref: triggerRef,
    // If it is a type description, we use tooltip to describe the trigger
    'aria-describedby': type === 'description' ? `tooltip-${tooltipId}` : undefined,
    // If it is a label type, we use tooltip to label the trigger
    'aria-labelledby': type === 'label' ? `tooltip-${tooltipId}` : undefined,
    onBlur: event => {
      var _child$props$onBlur, _child$props;
      closeTooltip();
      (_child$props$onBlur = (_child$props = child.props).onBlur) === null || _child$props$onBlur === void 0 ? void 0 : _child$props$onBlur.call(_child$props, event);
    },
    onFocus: event => {
      var _child$props$onFocus, _child$props2;
      openTooltip();
      (_child$props$onFocus = (_child$props2 = child.props).onFocus) === null || _child$props$onFocus === void 0 ? void 0 : _child$props$onFocus.call(_child$props2, event);
    },
    onMouseEnter: event => {
      var _child$props$onMouseE, _child$props3;
      openTooltip();
      (_child$props$onMouseE = (_child$props3 = child.props).onMouseEnter) === null || _child$props$onMouseE === void 0 ? void 0 : _child$props$onMouseE.call(_child$props3, event);
    }
  }), /*#__PURE__*/React__default.createElement(StyledTooltip, _extends({
    ref: tooltipElRef,
    "data-direction": calculatedDirection
  }, rest, {
    // Only need tooltip role if the tooltip is a description for supplementary information
    role: type === 'description' ? 'tooltip' : undefined
    // stop AT from announcing the tooltip twice when it is a label type because it will be announced with "aria-labelledby"
    ,
    "aria-hidden": type === 'label' ? true : undefined,
    id: `tooltip-${tooltipId}`
  }), text)));
});

export { Tooltip, TooltipContext };
